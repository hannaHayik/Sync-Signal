diff --git a/Makefile b/Makefile
index 09d790c..a8df47e 100644
--- a/Makefile
+++ b/Makefile
@@ -181,6 +181,7 @@ UPROGS=\
 	_usertests\
 	_wc\
 	_zombie\
+	_test\
 
 fs.img: mkfs README $(UPROGS)
 	./mkfs fs.img README $(UPROGS)
diff --git a/SaveSigAction.h b/SaveSigAction.h
new file mode 100644
index 0000000..d9d993f
--- /dev/null
+++ b/SaveSigAction.h
@@ -0,0 +1,5 @@
+struct sigaction
+{
+ void (*sa_handler)(int);
+ uint sigmask; 
+};
\ No newline at end of file
diff --git a/defs.h b/defs.h
index 82fb982..19b790c 100644
--- a/defs.h
+++ b/defs.h
@@ -9,6 +9,8 @@ struct spinlock;
 struct sleeplock;
 struct stat;
 struct superblock;
+struct sigaction;
+struct trapframe;
 
 // bio.c
 void            binit(void);
@@ -103,11 +105,15 @@ int             pipewrite(struct pipe*, char*, int);
 
 //PAGEBREAK: 16
 // proc.c
+void            sigret(void);
+uint            sigprocmask( uint sigmask );    //task2.1.3
+int             sigaction(int signum, const struct sigaction * act, struct sigaction *old);     //task2.1.4
+void            handleSignals(struct trapframe * tf);
 int             cpuid(void);
 void            exit(void);
 int             fork(void);
 int             growproc(int);
-int             kill(int);
+int             kill(int, int);
 struct cpu*     mycpu(void);
 struct proc*    myproc();
 void            pinit(void);
@@ -121,6 +127,7 @@ int             wait(void);
 void            wakeup(void*);
 void            yield(void);
 
+
 // swtch.S
 void            swtch(struct context**, struct context*);
 
diff --git a/exec.c b/exec.c
index b40134f..ab1b831 100644
--- a/exec.c
+++ b/exec.c
@@ -99,6 +99,13 @@ exec(char *path, char **argv)
   curproc->sz = sz;
   curproc->tf->eip = elf.entry;  // main
   curproc->tf->esp = sp;
+
+                                                                                      //Task2.1.2
+  for(int i=0; i<=31; i++){
+    if(curproc->signalHandlers[i]==(void*)SIG_IGN )
+    continue;
+    curproc->signalHandlers[i]=(void*)SIG_DFL;
+  }
   switchuvm(curproc);
   freevm(oldpgdir);
   return 0;
diff --git a/forktest.c b/forktest.c
index 8bc984d..89b87bd 100644
--- a/forktest.c
+++ b/forktest.c
@@ -27,7 +27,7 @@ forktest(void)
     if(pid == 0)
       exit();
   }
-
+  
   if(n == N){
     printf(1, "fork claimed to work N times!\n", N);
     exit();
@@ -39,6 +39,7 @@ forktest(void)
       exit();
     }
   }
+   
 
   if(wait() != -1){
     printf(1, "wait got too many\n");
diff --git a/kill.c b/kill.c
index 364f6af..cb22011 100644
--- a/kill.c
+++ b/kill.c
@@ -11,7 +11,10 @@ main(int argc, char **argv)
     printf(2, "usage: kill pid...\n");
     exit();
   }
-  for(i=1; i<argc; i++)
-    kill(atoi(argv[i]));
+  for(i=1; i<argc; i++){
+  int j=i+1;
+    kill(atoi(argv[i]),atoi(argv[j]));
+    i=i+1;
+  }
   exit();
 }
diff --git a/param.h b/param.h
index a7e90ef..c2e26e8 100644
--- a/param.h
+++ b/param.h
@@ -11,4 +11,9 @@
 #define LOGSIZE      (MAXOPBLOCKS*3)  // max data blocks in on-disk log
 #define NBUF         (MAXOPBLOCKS*3)  // size of disk block cache
 #define FSSIZE       1000  // size of file system in blocks
+#define SIG_DFL     0               //default signal handling
+#define SIG_IGN     1               //ignore signal
+#define  SIGKILL    9
+#define SIGSTOP    17
+#define SIGCONT    19
 
diff --git a/proc.c b/proc.c
index d3c8b17..2e633d4 100644
--- a/proc.c
+++ b/proc.c
@@ -6,8 +6,18 @@
 #include "x86.h"
 #include "proc.h"
 #include "spinlock.h"
+#include "SaveSigAction.h"
 
-struct {
+//New assignment functions
+int wakeUpLock = 0;                       // in order to synchronize between exit and wakeup
+extern void callSigretASM(void);          //trapasm.s
+extern void endSigretASM(void);           //trapasm.s
+void handleSignals(struct trapframe *tf); //proc.c
+void sigret(void);                        //proc.c
+uint sigprocmask(uint sigmask);           //proc.c
+
+struct
+{
   struct spinlock lock;
   struct proc proc[NPROC];
 } ptable;
@@ -20,32 +30,32 @@ extern void trapret(void);
 
 static void wakeup1(void *chan);
 
-void
-pinit(void)
+void pinit(void)
 {
   initlock(&ptable.lock, "ptable");
 }
 
 // Must be called with interrupts disabled
-int
-cpuid() {
-  return mycpu()-cpus;
+int cpuid()
+{
+  return mycpu() - cpus;
 }
 
 // Must be called with interrupts disabled to avoid the caller being
 // rescheduled between reading lapicid and running through the loop.
-struct cpu*
+struct cpu *
 mycpu(void)
 {
   int apicid, i;
-  
-  if(readeflags()&FL_IF)
+
+  if (readeflags() & FL_IF)
     panic("mycpu called with interrupts enabled\n");
-  
+
   apicid = lapicid();
   // APIC IDs are not guaranteed to be contiguous. Maybe we should have
   // a reverse map, or reserve a register to store &cpus[i].
-  for (i = 0; i < ncpu; ++i) {
+  for (i = 0; i < ncpu; ++i)
+  {
     if (cpus[i].apicid == apicid)
       return &cpus[i];
   }
@@ -54,8 +64,9 @@ mycpu(void)
 
 // Disable interrupts so that we are not rescheduled
 // while reading proc from the cpu structure
-struct proc*
-myproc(void) {
+struct proc *
+myproc(void)
+{
   struct cpu *c;
   struct proc *p;
   pushcli();
@@ -65,17 +76,15 @@ myproc(void) {
   return p;
 }
 
-
-
-
-int 
-allocpid(void) 
+int allocpid(void)
 {
-  int pid;
-  acquire(&ptable.lock);
-  pid = nextpid++;
-  release(&ptable.lock);
-  return pid;
+  //Task3
+  int pid = 0;
+  do
+  {
+    pid = nextpid;
+  } while (cas(&nextpid, pid, nextpid + 1) == 0);
+  return pid + 1;
 }
 
 //PAGEBREAK: 32
@@ -83,66 +92,73 @@ allocpid(void)
 // If found, change state to EMBRYO and initialize
 // state required to run in the kernel.
 // Otherwise return 0.
-static struct proc*
+static struct proc *
 allocproc(void)
 {
   struct proc *p;
   char *sp;
+  pushcli();
+  do                              //CAS ensures only 1 CPU catches the slot, Do-While ensures no CPU is stuck
+  {
+
+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+    {
+      if (p->state == UNUSED)
+      {
+        break;
+      }
+    }
+    if (p == &ptable.proc[NPROC]) //no empty slots!
+    {
+      popcli();
+      return 0;
+    }
 
-  acquire(&ptable.lock);
-
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-    if(p->state == UNUSED)
-      goto found;
-
-  release(&ptable.lock);
-  return 0;
+  } while (cas(&(p->state), UNUSED, EMBRYO) == 0);
+  popcli();
 
-found:
-  p->state = EMBRYO;
-  release(&ptable.lock);
+                                //Found UNUSED slot
+  for (int i = 0; i < 32; i++)  //init all signal handlers to SIG_DFL
+    p->signalHandlers[i] = (void *)SIG_DFL;
 
+  p->isStop = 0;                //variable to recognize SIGSTOP signal
+  p->ignore_signals = 0;        //flag to not handle nested-user defined functions
   p->pid = allocpid();
 
   // Allocate kernel stack.
-  if((p->kstack = kalloc()) == 0){
+  if ((p->kstack = kalloc()) == 0)
+  {
     p->state = UNUSED;
     return 0;
   }
   sp = p->kstack + KSTACKSIZE;
-
   // Leave room for trap frame.
   sp -= sizeof *p->tf;
-  p->tf = (struct trapframe*)sp;
-
+  p->tf = (struct trapframe *)sp;
   // Set up new context to start executing at forkret,
   // which returns to trapret.
   sp -= 4;
-  *(uint*)sp = (uint)trapret;
+  *(uint *)sp = (uint)trapret;
 
   sp -= sizeof *p->context;
-  p->context = (struct context*)sp;
+  p->context = (struct context *)sp;
   memset(p->context, 0, sizeof *p->context);
   p->context->eip = (uint)forkret;
 
   return p;
 }
 
-
-
-
 //PAGEBREAK: 32
 // Set up first user process.
-void
-userinit(void)
+void userinit(void)
 {
   struct proc *p;
   extern char _binary_initcode_start[], _binary_initcode_size[];
 
   p = allocproc();
-  
+
   initproc = p;
-  if((p->pgdir = setupkvm()) == 0)
+  if ((p->pgdir = setupkvm()) == 0)
     panic("userinit: out of memory?");
   inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
   p->sz = PGSIZE;
@@ -153,7 +169,7 @@ userinit(void)
   p->tf->ss = p->tf->ds;
   p->tf->eflags = FL_IF;
   p->tf->esp = PGSIZE;
-  p->tf->eip = 0;  // beginning of initcode.S
+  p->tf->eip = 0; // beginning of initcode.S
 
   safestrcpy(p->name, "initcode", sizeof(p->name));
   p->cwd = namei("/");
@@ -162,27 +178,38 @@ userinit(void)
   // run this process. the acquire forces the above
   // writes to be visible, and the lock is also needed
   // because the assignment might not be atomic.
-  acquire(&ptable.lock);
+
+
+  /*acquire(&ptable.lock);      //Removed
 
   p->state = RUNNABLE;
 
-  release(&ptable.lock);
+  release(&ptable.lock);*/
+
+  pushcli();
+  if (cas(&p->state, EMBRYO, RUNNABLE) == 0)     
+  {
+    panic("INITPROC FAILED LINE 1st");    //if it's not EMBRYO, something went wrong!
+  }
+  popcli();
 }
 
 // Grow current process's memory by n bytes.
 // Return 0 on success, -1 on failure.
-int
-growproc(int n)
+int growproc(int n)
 {
   uint sz;
   struct proc *curproc = myproc();
 
   sz = curproc->sz;
-  if(n > 0){
-    if((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
+  if (n > 0)
+  {
+    if ((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
       return -1;
-  } else if(n < 0){
-    if((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
+  }
+  else if (n < 0)
+  {
+    if ((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
       return -1;
   }
   curproc->sz = sz;
@@ -193,20 +220,21 @@ growproc(int n)
 // Create a new process copying p as the parent.
 // Sets up stack to return as if from system call.
 // Caller must set state of returned proc to RUNNABLE.
-int
-fork(void)
+int fork(void)
 {
   int i, pid;
   struct proc *np;
   struct proc *curproc = myproc();
 
   // Allocate process.
-  if((np = allocproc()) == 0){
+  if ((np = allocproc()) == 0)
+  {
     return -1;
   }
 
   // Copy process state from proc.
-  if((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0){
+  if ((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0)
+  {
     kfree(np->kstack);
     np->kstack = 0;
     np->state = UNUSED;
@@ -216,43 +244,53 @@ fork(void)
   np->parent = curproc;
   *np->tf = *curproc->tf;
 
+  //Task2.1.2
+  np->signalMask = curproc->signalMask;     //child process takes father's mask & signal handlers
+  for (int i = 0; i <= 31; i++)
+  {
+    np->signalHandlers[i] = curproc->signalHandlers[i];
+  }
+  np->pendingSignals = 0;                   //child has no pending signals
+  np->ignore_signals = 0;                   //child has no nested-user defined functions running yet
+  
+
   // Clear %eax so that fork returns 0 in the child.
   np->tf->eax = 0;
 
-  for(i = 0; i < NOFILE; i++)
-    if(curproc->ofile[i])
+  for (i = 0; i < NOFILE; i++)
+    if (curproc->ofile[i])
       np->ofile[i] = filedup(curproc->ofile[i]);
   np->cwd = idup(curproc->cwd);
 
   safestrcpy(np->name, curproc->name, sizeof(curproc->name));
 
   pid = np->pid;
-
-  acquire(&ptable.lock);
-
-  np->state = RUNNABLE;
-
-  release(&ptable.lock);
-
+  pushcli();
+  if (cas(&np->state, EMBRYO, RUNNABLE) == 0)
+  {
+    panic("FORK FAILED LINE 1st");
+  }
+  popcli();
   return pid;
 }
 
 // Exit the current process.  Does not return.
 // An exited process remains in the zombie state
 // until its parent calls wait() to find out it exited.
-void
-exit(void)
+void exit(void)
 {
   struct proc *curproc = myproc();
   struct proc *p;
   int fd;
 
-  if(curproc == initproc)
+  if (curproc == initproc)
     panic("init exiting");
 
   // Close all open files.
-  for(fd = 0; fd < NOFILE; fd++){
-    if(curproc->ofile[fd]){
+  for (fd = 0; fd < NOFILE; fd++)
+  {
+    if (curproc->ofile[fd])
+    {
       fileclose(curproc->ofile[fd]);
       curproc->ofile[fd] = 0;
     }
@@ -263,44 +301,60 @@ exit(void)
   end_op();
   curproc->cwd = 0;
 
-  acquire(&ptable.lock);
+  //acquire(&ptable.lock);
+  pushcli();
 
+  if (cas(&curproc->state, RUNNING, NEG_ZOMBIE) == 0)
+  {
+    panic("EXIT FAILED LINE 1st");
+  }
   // Parent might be sleeping in wait().
   wakeup1(curproc->parent);
 
   // Pass abandoned children to init.
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-    if(p->parent == curproc){
+  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+  {
+    if (p->parent == curproc)
+    {
       p->parent = initproc;
-      if(p->state == ZOMBIE)
+      if (p->state == ZOMBIE || p->state == NEG_ZOMBIE)
         wakeup1(initproc);
     }
   }
 
   // Jump into the scheduler, never to return.
-  curproc->state = ZOMBIE;
+  //curproc->state = ZOMBIE;
+
   sched();
-  panic("zombie exit");
+  //cprintf("DEBUG---   PID:%d    state:%d      name:%s\n",curproc->pid,curproc->state,curproc->name);
+  panic("zombie exit");         //shouldn't be reached
 }
 
 // Wait for a child process to exit and return its pid.
 // Return -1 if this process has no children.
-int
-wait(void)
+int wait(void)
 {
   struct proc *p;
   int havekids, pid;
   struct proc *curproc = myproc();
-  
-  acquire(&ptable.lock);
-  for(;;){
+
+  pushcli();
+  for (;;)
+  {
+    if (cas(&curproc->state, RUNNING, NEG_SLEEPING) == 0)
+    {
+      panic("WAIT FAILED LINE 1st");
+    }
+    curproc->chan = curproc;
     // Scan through table looking for exited children.
     havekids = 0;
-    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-      if(p->parent != curproc)
+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+    {
+      if (p->parent != curproc)
         continue;
       havekids = 1;
-      if(p->state == ZOMBIE){
+      if (p->state == ZOMBIE)
+      {
         // Found one.
         pid = p->pid;
         kfree(p->kstack);
@@ -310,20 +364,30 @@ wait(void)
         p->parent = 0;
         p->name[0] = 0;
         p->killed = 0;
-        p->state = UNUSED;
-        release(&ptable.lock);
+        p->state = UNUSED;    //No need for CAS (Zombie before)
+        curproc->chan = 0;
+        if (cas(&curproc->state, NEG_SLEEPING, RUNNING) == 0)
+        {
+          panic("WAIT FAILED LINE 2nd");
+        }
+        popcli();
         return pid;
       }
     }
 
     // No point waiting if we don't have any children.
-    if(!havekids || curproc->killed){
-      release(&ptable.lock);
+    if (!havekids || curproc->killed)
+    {
+      curproc->chan = 0;
+      if (cas(&curproc->state, NEG_SLEEPING, RUNNING) == 0)
+        panic("WAIT FAILED LINE 3rd");
+      popcli();
       return -1;
     }
 
-    // Wait for children to exit.  (See wakeup1 call in proc_exit.)
-    sleep(curproc, &ptable.lock);  //DOC: wait-sleep
+    // Wait for children to exit.  
+    // sleep(curproc, &ptable.lock);
+    sched();                         //Process turns to SLEEPING in scheduler()
   }
 }
 
@@ -335,29 +399,33 @@ wait(void)
 //  - swtch to start running that process
 //  - eventually that process transfers control
 //      via swtch back to the scheduler.
-void
-scheduler(void)
+void scheduler(void)
 {
   struct proc *p;
   struct cpu *c = mycpu();
   c->proc = 0;
-  
-  for(;;){
+
+  for (;;)
+  {
     // Enable interrupts on this processor.
     sti();
 
     // Loop over process table looking for process to run.
-    acquire(&ptable.lock);
-    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-      if(p->state != RUNNABLE)
+    pushcli();
+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+    {
+      if (!cas(&p->state, RUNNABLE, RUNNING))
+      {
         continue;
+      }
 
       // Switch to chosen process.  It is the process's job
       // to release ptable.lock and then reacquire it
       // before jumping back to us.
+
+      //cprintf("DEBUG---   PID:%d    state:%d      name:%s\n",p->pid,p->state,p->name);
       c->proc = p;
       switchuvm(p);
-      p->state = RUNNING;
 
       swtch(&(c->scheduler), p->context);
       switchkvm();
@@ -365,9 +433,20 @@ scheduler(void)
       // Process is done running for now.
       // It should have changed its p->state before coming back.
       c->proc = 0;
+      if (cas(&p->state, NEG_SLEEPING, SLEEPING))
+      {
+        if (p->killed == 1)
+        {
+          cas(&p->state, SLEEPING, RUNNABLE);
+        }
+      }
+      cas(&p->state, NEG_RUNNABLE, RUNNABLE);
+      if (cas(&p->state, NEG_ZOMBIE, ZOMBIE))
+      {
+        wakeup1(p->parent);
+      }
     }
-    release(&ptable.lock);
-
+    popcli();
   }
 }
 
@@ -378,19 +457,15 @@ scheduler(void)
 // be proc->intena and proc->ncli, but that would
 // break in the few places where a lock is held but
 // there's no process.
-void
-sched(void)
+void sched(void)
 {
   int intena;
   struct proc *p = myproc();
-
-  if(!holding(&ptable.lock))
-    panic("sched ptable.lock");
-  if(mycpu()->ncli != 1)
+  if (mycpu()->ncli != 1)
     panic("sched locks");
-  if(p->state == RUNNING)
+  if (p->state == RUNNING)
     panic("sched running");
-  if(readeflags()&FL_IF)
+  if (readeflags() & FL_IF)
     panic("sched interruptible");
   intena = mycpu()->intena;
   swtch(&p->context, mycpu()->scheduler);
@@ -398,25 +473,29 @@ sched(void)
 }
 
 // Give up the CPU for one scheduling round.
-void
-yield(void)
+void yield(void)
 {
-  acquire(&ptable.lock);  //DOC: yieldlock
-  myproc()->state = RUNNABLE;
+
+  //acquire(&ptable.lock); //DOC: yieldlock
+  pushcli();
+  if (cas(&myproc()->state, RUNNING, NEG_RUNNABLE) == 0)
+  {
+    panic("YIELD FAILED LINE 374");
+  }
   sched();
-  release(&ptable.lock);
+  popcli();
 }
 
 // A fork child's very first scheduling by scheduler()
 // will swtch here.  "Return" to user space.
-void
-forkret(void)
+void forkret(void)
 {
   static int first = 1;
   // Still holding ptable.lock from scheduler.
-  release(&ptable.lock);
-
-  if (first) {
+  //release(&ptable.lock);
+  popcli();
+  if (first)
+  {
     // Some initialization functions must be run in the context
     // of a regular process (e.g., they call sleep), and thus cannot
     // be run from main().
@@ -430,15 +509,14 @@ forkret(void)
 
 // Atomically release lock and sleep on chan.
 // Reacquires lock when awakened.
-void
-sleep(void *chan, struct spinlock *lk)
+void sleep(void *chan, struct spinlock *lk)
 {
   struct proc *p = myproc();
-  
-  if(p == 0)
+
+  if (p == 0)
     panic("sleep");
 
-  if(lk == 0)
+  if (lk == 0)
     panic("sleep without lk");
 
   // Must acquire ptable.lock in order to
@@ -447,24 +525,21 @@ sleep(void *chan, struct spinlock *lk)
   // guaranteed that we won't miss any wakeup
   // (wakeup runs with ptable.lock locked),
   // so it's okay to release lk.
-  if(lk != &ptable.lock){  //DOC: sleeplock0
-    acquire(&ptable.lock);  //DOC: sleeplock1
-    release(lk);
-  }
+
+  pushcli();
+  release(lk);
   // Go to sleep.
   p->chan = chan;
-  p->state = SLEEPING;
-
+  if (cas(&p->state, RUNNING, NEG_SLEEPING) == 0)
+    panic("CAS failed, sleep() 1st");
   sched();
 
   // Tidy up.
   p->chan = 0;
 
   // Reacquire original lock.
-  if(lk != &ptable.lock){  //DOC: sleeplock2
-    release(&ptable.lock);
-    acquire(lk);
-  }
+  acquire(lk);
+  popcli();
 }
 
 //PAGEBREAK!
@@ -474,41 +549,60 @@ static void
 wakeup1(void *chan)
 {
   struct proc *p;
-
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-    if(p->state == SLEEPING && p->chan == chan)
-      p->state = RUNNABLE;
+  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+  {
+    if ((p->chan == chan) && (p->state == SLEEPING || p->state == NEG_SLEEPING))
+    {
+      while (cas(&p->state, SLEEPING, NEG_RUNNABLE) == 0)   //try to make it RUNNABLE
+      {
+        if (p->state == RUNNING)                            //was woken by someone else and ran by another CPU
+          break;
+      }
+      if (p->state != RUNNING)                              //if not RUNNING, make it RUNNABLE
+      {
+        p->chan = 0;
+        if (cas(&p->state, NEG_RUNNABLE, RUNNABLE) == 0)
+          panic("WAKEUP FAILED LINE 1st");
+      }
+    }
+  }
 }
-
 // Wake up all processes sleeping on chan.
-void
-wakeup(void *chan)
+void wakeup(void *chan)
 {
-  acquire(&ptable.lock);
+  pushcli();
+  //acquire(&ptable.lock);
   wakeup1(chan);
-  release(&ptable.lock);
+  //release(&ptable.lock);
+  popcli();
 }
 
 // Kill the process with the given pid.
 // Process won't exit until it returns
 // to user space (see trap in trap.c).
-int
-kill(int pid)
+int kill(int pid, int signum)
 {
   struct proc *p;
 
-  acquire(&ptable.lock);
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-    if(p->pid == pid){
-      p->killed = 1;
-      // Wake process from sleep if necessary.
-      if(p->state == SLEEPING)
-        p->state = RUNNABLE;
-      release(&ptable.lock);
+  //acquire(&ptable.lock);
+  pushcli();
+  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+  {
+    if (p->pid == pid)
+    {
+      if (signum == SIGKILL)
+      {
+        p->killed = 1;                    //task 2.2.1, kill now only send signals (not eliminate processess)
+        // Wake process from sleep if necessary.
+        if (p->state == SLEEPING)
+          cas(&p->state, SLEEPING, RUNNABLE);           //p can change state between the IF and CAS statements by other CPUs
+      }
+      p->pendingSignals = p->pendingSignals | (1 << signum);          //raise the signal
+      popcli();
       return 0;
     }
   }
-  release(&ptable.lock);
+  popcli();
   return -1;
 }
 
@@ -516,35 +610,207 @@ kill(int pid)
 // Print a process listing to console.  For debugging.
 // Runs when user types ^P on console.
 // No lock to avoid wedging a stuck machine further.
-void
-procdump(void)
+void procdump(void)
 {
   static char *states[] = {
-  [UNUSED]    "unused",
-  [EMBRYO]    "embryo",
-  [SLEEPING]  "sleep ",
-  [RUNNABLE]  "runble",
-  [RUNNING]   "run   ",
-  [ZOMBIE]    "zombie"
+      [UNUSED] "unused",
+      [EMBRYO] "embryo",
+      [SLEEPING] "sleep ",
+      [RUNNABLE] "runble",
+      [RUNNING] "run   ",
+      [ZOMBIE] "zombie",
+      [NEG_UNUSED] "neg_unused",
+      [NEG_EMBRYO] "neg_embryo",
+      [NEG_SLEEPING] "neg_sleeping",
+      [NEG_RUNNABLE] "neg_runnable",
+      [NEG_ZOMBIE] "neg_zombie",
   };
   int i;
   struct proc *p;
   char *state;
   uint pc[10];
 
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-    if(p->state == UNUSED)
+  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+  {
+    if (p->state == UNUSED)
       continue;
-    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
+    if (p->state >= 0 && p->state < NELEM(states) && states[p->state])
       state = states[p->state];
     else
       state = "???";
     cprintf("%d %s %s", p->pid, state, p->name);
-    if(p->state == SLEEPING){
-      getcallerpcs((uint*)p->context->ebp+2, pc);
-      for(i=0; i<10 && pc[i] != 0; i++)
+    if (p->state == SLEEPING)
+    {
+      getcallerpcs((uint *)p->context->ebp + 2, pc);
+      for (i = 0; i < 10 && pc[i] != 0; i++)
         cprintf(" %p", pc[i]);
     }
     cprintf("\n");
   }
 }
+//Task 2.1.3    
+//Changes process signal's mask, Returns old mask                                                                          
+uint sigprocmask(uint sigmask)
+{
+  uint old = myproc()->signalMask;
+  myproc()->backUpSignalMask = sigmask;
+  myproc()->signalMask = sigmask;
+  return old;
+}
+
+//task2.1.4
+//Replaces signum handler & mask, Returns old ones                                                                             
+int sigaction(int signum, const struct sigaction *act, struct sigaction *old)
+{
+  void *oldaction;
+  if (old != null)
+    oldaction = myproc()->signalHandlers[signum];
+  int ans = -1;
+  if (signum != SIGKILL && signum != SIGSTOP)
+  {
+    if (act != null)
+    {
+      myproc()->masks[signum] = act->sigmask;
+      myproc()->signalHandlers[signum] = act->sa_handler;
+      ans = 0;
+    }
+    if (old != null)
+    {
+      old->sa_handler = oldaction;
+    }
+  }
+
+  return ans;
+}
+//Task2.1.5
+//Applies the backup frame to current procces (changes the ESP to clean stack)
+void sigret(void)
+{
+  struct proc *p = myproc();
+  memmove(p->tf, p->backUp, sizeof(struct trapframe));
+  p->tf->esp += sizeof(struct trapframe);
+  p->ignore_signals = 0;                            //to avoid nested user defined handlers
+}
+
+//task 2.3.1
+//To handle signals with SIGKILL handler (not neccessary)
+int sigkill(int pid)
+{
+
+  struct proc *p;
+  pushcli();
+  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+  {
+    if (p->pid == pid)
+    {
+      p->killed = 1;
+
+      // Wake process from sleep if necessary.
+      if (p->state == SLEEPING)
+        //p->state = RUNNABLE;
+        if (cas(&myproc()->state, SLEEPING, RUNNABLE) == 0)
+        {
+          panic("SIGKILL FAILED LINE 710");
+        }
+      popcli();
+      return 0;
+    }
+  }
+  popcli();
+  return -1;
+}
+
+void handleSignals(struct trapframe *tf)
+{
+  if ((tf->cs & 3) != DPL_USER)
+    return;
+  if (myproc() == 0)
+    return;
+  if (myproc()->pendingSignals == 0)
+    return;
+  if (myproc()->killed == 1)
+    return;
+
+  for (int i = 0; i < 32; i++)
+  {
+    //cprintf("starting loop index:%d\n", i);
+    if (((myproc()->pendingSignals & 1 << i) == 1 << i) && ((myproc()->signalMask & 1 << i) == 0))
+    {
+      if ((myproc()->signalHandlers[i] == (void *)SIG_DFL) || (myproc()->signalHandlers[i] == (void *)SIGCONT) || (myproc()->signalHandlers[i] == (void *)SIGSTOP) || (myproc()->signalHandlers[i] == (void *)SIGKILL) || (myproc()->signalHandlers[i] == (void *)SIG_IGN))
+      {
+        if ((i == SIGSTOP) || (myproc()->signalHandlers[i] == (void *)SIGSTOP))
+        {
+          if (i != SIGSTOP)
+            myproc()->signalMask = myproc()->masks[i];
+          myproc()->isStop = 1;                              //proccess received SIGSTOP
+          myproc()->pendingSignals ^= 1UL << i;              //set signal's bit off
+          myproc()->signalMask = myproc()->backUpSignalMask; //turn the old mask back on after handling signal
+          while (myproc()->isStop == 1)
+          {
+            for (int i = 0; i < 32; i++)                     //if a pending signal is on && isn't blocked by signalMask && has SIGCONT handler/ its SIGCONT (number 19)
+            {
+              if ((((myproc()->pendingSignals & 1 << i) == 1 << i) && ((myproc()->signalMask & 1 << i) == 0) && (myproc()->signalHandlers[i] == (void *)SIGCONT)) ||
+                  (((myproc()->pendingSignals & 1 << i) == 1 << i) && (i == SIGCONT)))
+              {
+                myproc()->isStop = 0;                    //SIGSTOP no more
+                myproc()->pendingSignals ^= 1UL << i;    //set signal's bit off
+                return;
+              }                                          //SIGKILL can override SIGSTOP and can't be blocked so we check it(or any other signal with SIGKILL handler)
+              if ((((myproc()->pendingSignals & 1 << i) == 1 << i) && ((myproc()->signalMask & 1 << i) == 0) && (myproc()->signalHandlers[i] == (void *)SIGKILL)) ||
+                  (((myproc()->pendingSignals & 1 << i) == 1 << i) && (i == SIGKILL)))
+              {
+                sigkill(myproc()->pid);                     //use sigkill to kill proccess (can copy code here)
+                myproc()->pendingSignals ^= 1UL << i;       //set signal's bit off
+                return;
+              }
+            }
+          }
+        }
+        if ((i == SIGCONT) || (myproc()->signalHandlers[i] == (void *)SIGCONT) || ((myproc()->signalHandlers[i] == (void *)SIG_IGN))) //SIG_IGN & SIGCONT have no effect (without SIGSTOP)
+        {
+          myproc()->pendingSignals ^= 1UL << i;             //set signal's bit off
+          continue;
+        }
+        else
+        {                                                 
+          if (i != SIGKILL)
+            myproc()->signalMask = myproc()->masks[i];
+          sigkill(myproc()->pid);                           //either SIGKILL or SIG_DFL (which is kill by default)
+          myproc()->pendingSignals ^= 1UL << i;             //set signal's bit off
+        }
+        myproc()->signalMask = myproc()->backUpSignalMask;  //turn the old mask back on after handling signal
+      }
+      else if (myproc()->ignore_signals == 0)
+      {
+        { //User Defined Handler is picked
+          // cprintf("USER DEFINED signal:%d\n", i);
+          myproc()->ignore_signals = 1;                               //ignore user-defined handlers
+          myproc()->signalMask = myproc()->masks[i];                  //turn on user-defined handler's mask
+
+          myproc()->tf->esp -= sizeof(struct trapframe);              //move the esp (by size of trapframe)
+
+          myproc()->backUp = (struct trapframe *)(myproc()->tf->esp); //allocate (76 UL) bytes to backup trapframe on user stack
+
+          memmove(myproc()->backUp, myproc()->tf, sizeof(struct trapframe)); //backup the current trapframe
+
+          myproc()->tf->esp -= (endSigretASM - callSigretASM);        //move the esp (by size of injected ASM code (7UL))
+
+          memmove((void *)(myproc()->tf->esp), callSigretASM, (endSigretASM - callSigretASM)); //inject ASM code in user's stack (calls sigret)
+
+          *((int *)(myproc()->tf->esp - 4)) = i;                      //push signum as argument to user defined handler on user's stack
+
+          *((int *)(myproc()->tf->esp - 8)) = myproc()->tf->esp;      //push the ret address (to callSigretASM) to user stack
+
+          myproc()->tf->esp -= 8;                                     //let ESP point on ret address
+
+          myproc()->tf->eip = (uint)(myproc()->signalHandlers[i]);    //change instruction pointer (call user defined handler)
+
+          myproc()->pendingSignals ^= 1UL << i;                       //set signal's bit off
+
+          myproc()->signalMask = myproc()->backUpSignalMask;          //turn the old mask back on after handling signal
+          return;
+        }
+      }
+    }
+  }
+}
diff --git a/proc.h b/proc.h
index 1647114..1f57819 100644
--- a/proc.h
+++ b/proc.h
@@ -32,10 +32,18 @@ struct context {
   uint eip;
 };
 
-enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
+enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE, NEG_UNUSED, NEG_EMBRYO, NEG_SLEEPING, NEG_RUNNABLE, NEG_RUNNING, NEG_ZOMBIE};
 
 // Per-process state
 struct proc {
+  uint pendingSignals;                              //Task2.1  sizeof unit is 32bit
+  uint signalMask;                                  //Task2.1
+  void* signalHandlers[32];                         //Task2.1
+  struct trapframe *backUp;                         //Task2.1
+  uint backUpSignalMask;                            //Task2.1
+  int isStop;                                       //Task2.1
+  int ignore_signals;                               //Task2.1
+  uint masks[32];                                   //Task2.1
   uint sz;                     // Size of process memory (bytes)
   pde_t* pgdir;                // Page table
   char *kstack;                // Bottom of kernel stack for this process
@@ -55,4 +63,7 @@ struct proc {
 //   text
 //   original data and bss
 //   fixed-size stack
-//   expandable heap
+//   expandable heap  
+
+
+
diff --git a/syscall.c b/syscall.c
index ee85261..17a249f 100644
--- a/syscall.c
+++ b/syscall.c
@@ -14,58 +14,55 @@
 // to a saved program counter, and then the first argument.
 
 // Fetch the int at addr from the current process.
-int
-fetchint(uint addr, int *ip)
+int fetchint(uint addr, int *ip)
 {
   struct proc *curproc = myproc();
 
-  if(addr >= curproc->sz || addr+4 > curproc->sz)
+  if (addr >= curproc->sz || addr + 4 > curproc->sz)
     return -1;
-  *ip = *(int*)(addr);
+  *ip = *(int *)(addr);
   return 0;
 }
 
 // Fetch the nul-terminated string at addr from the current process.
 // Doesn't actually copy the string - just sets *pp to point at it.
 // Returns length of string, not including nul.
-int
-fetchstr(uint addr, char **pp)
+int fetchstr(uint addr, char **pp)
 {
   char *s, *ep;
   struct proc *curproc = myproc();
 
-  if(addr >= curproc->sz)
+  if (addr >= curproc->sz)
     return -1;
-  *pp = (char*)addr;
-  ep = (char*)curproc->sz;
-  for(s = *pp; s < ep; s++){
-    if(*s == 0)
+  *pp = (char *)addr;
+  ep = (char *)curproc->sz;
+  for (s = *pp; s < ep; s++)
+  {
+    if (*s == 0)
       return s - *pp;
   }
   return -1;
 }
 
 // Fetch the nth 32-bit system call argument.
-int
-argint(int n, int *ip)
+int argint(int n, int *ip)
 {
-  return fetchint((myproc()->tf->esp) + 4 + 4*n, ip);
+  return fetchint((myproc()->tf->esp) + 4 + 4 * n, ip);
 }
 
 // Fetch the nth word-sized system call argument as a pointer
 // to a block of memory of size bytes.  Check that the pointer
 // lies within the process address space.
-int
-argptr(int n, char **pp, int size)
+int argptr(int n, char **pp, int size)
 {
   int i;
   struct proc *curproc = myproc();
- 
-  if(argint(n, &i) < 0)
+
+  if (argint(n, &i) < 0)
     return -1;
-  if(size < 0 || (uint)i >= curproc->sz || (uint)i+size > curproc->sz)
+  if (size < 0 || (uint)i >= curproc->sz || (uint)i + size > curproc->sz)
     return -1;
-  *pp = (char*)i;
+  *pp = (char *)i;
   return 0;
 }
 
@@ -73,11 +70,10 @@ argptr(int n, char **pp, int size)
 // Check that the pointer is valid and the string is nul-terminated.
 // (There is no shared writable memory, so the string can't change
 // between this check and being used by the kernel.)
-int
-argstr(int n, char **pp)
+int argstr(int n, char **pp)
 {
   int addr;
-  if(argint(n, &addr) < 0)
+  if (argint(n, &addr) < 0)
     return -1;
   return fetchstr(addr, pp);
 }
@@ -103,41 +99,49 @@ extern int sys_unlink(void);
 extern int sys_wait(void);
 extern int sys_write(void);
 extern int sys_uptime(void);
+extern int sys_sigprocmask(void); //task 2.1.3
+extern int sys_sigaction(void);     //task2.1.4
+extern int sys_sigret(void);        //task
 
 static int (*syscalls[])(void) = {
-[SYS_fork]    sys_fork,
-[SYS_exit]    sys_exit,
-[SYS_wait]    sys_wait,
-[SYS_pipe]    sys_pipe,
-[SYS_read]    sys_read,
-[SYS_kill]    sys_kill,
-[SYS_exec]    sys_exec,
-[SYS_fstat]   sys_fstat,
-[SYS_chdir]   sys_chdir,
-[SYS_dup]     sys_dup,
-[SYS_getpid]  sys_getpid,
-[SYS_sbrk]    sys_sbrk,
-[SYS_sleep]   sys_sleep,
-[SYS_uptime]  sys_uptime,
-[SYS_open]    sys_open,
-[SYS_write]   sys_write,
-[SYS_mknod]   sys_mknod,
-[SYS_unlink]  sys_unlink,
-[SYS_link]    sys_link,
-[SYS_mkdir]   sys_mkdir,
-[SYS_close]   sys_close,
+    [SYS_fork] sys_fork,
+    [SYS_exit] sys_exit,
+    [SYS_wait] sys_wait,
+    [SYS_pipe] sys_pipe,
+    [SYS_read] sys_read,
+    [SYS_kill] sys_kill,
+    [SYS_exec] sys_exec,
+    [SYS_fstat] sys_fstat,
+    [SYS_chdir] sys_chdir,
+    [SYS_dup] sys_dup,
+    [SYS_getpid] sys_getpid,
+    [SYS_sbrk] sys_sbrk,
+    [SYS_sleep] sys_sleep,
+    [SYS_uptime] sys_uptime,
+    [SYS_open] sys_open,
+    [SYS_write] sys_write,
+    [SYS_mknod] sys_mknod,
+    [SYS_unlink] sys_unlink,
+    [SYS_link] sys_link,
+    [SYS_mkdir] sys_mkdir,
+    [SYS_close] sys_close,
+    [SYS_sigprocmask]  sys_sigprocmask,
+    [SYS_sigaction]    sys_sigaction,
+    [SYS_sigret]   sys_sigret ,
 };
 
-void
-syscall(void)
+void syscall(void)
 {
   int num;
   struct proc *curproc = myproc();
 
   num = curproc->tf->eax;
-  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
+  if (num > 0 && num < NELEM(syscalls) && syscalls[num])
+  {
     curproc->tf->eax = syscalls[num]();
-  } else {
+  }
+  else
+  {
     cprintf("%d %s: unknown sys call %d\n",
             curproc->pid, curproc->name, num);
     curproc->tf->eax = -1;
diff --git a/syscall.h b/syscall.h
index bc5f356..76d98c1 100644
--- a/syscall.h
+++ b/syscall.h
@@ -20,3 +20,6 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_sigprocmask 22 //TASK 2.1.3
+#define SYS_sigaction   23
+#define SYS_sigret      24
\ No newline at end of file
diff --git a/sysproc.c b/sysproc.c
index 0686d29..89c5fcb 100644
--- a/sysproc.c
+++ b/sysproc.c
@@ -6,68 +6,94 @@
 #include "memlayout.h"
 #include "mmu.h"
 #include "proc.h"
+int sys_sigret(void){
+  sigret();
+  return 0;
+}
+int sys_sigaction(void)
+{
+  int signum;
+  struct sigaction *act;
+  struct sigaction *oldAct;
+  if (argint(0, &signum) < 0)
+    return -1;
+  if (argptr(1, (void *)&act, sizeof(act)) < 0)
+    return -1;
+  if (argptr(2, (void *)&oldAct, sizeof(oldAct)) < 0)
+    return -1;
 
-int
-sys_fork(void)
+  return sigaction(signum, act, oldAct);
+}
+//Task2.1.3
+int sys_sigprocmask(void)
+{
+  int mask;
+  argint(0, &mask);
+  if (mask >= 0)
+  {
+    return sigprocmask(mask);
+  }
+  return -1 ;
+}
+int sys_fork(void)
 {
   return fork();
 }
 
-int
-sys_exit(void)
+int sys_exit(void)
 {
   exit();
-  return 0;  // not reached
+  return 0; // not reached
 }
 
-int
-sys_wait(void)
+int sys_wait(void)
 {
   return wait();
 }
 
-int
-sys_kill(void)
+int sys_kill(void)
 {
   int pid;
-
-  if(argint(0, &pid) < 0)
+  int signum;
+  if (argint(0, &pid) < 0)
     return -1;
-  return kill(pid);
+  if(argint(1,&signum)<0)
+  return -1;
+
+  return kill(pid,signum);
 }
 
-int
-sys_getpid(void)
+int sys_getpid(void)
 {
   return myproc()->pid;
 }
 
-int
-sys_sbrk(void)
+int sys_sbrk(void)
 {
   int addr;
   int n;
 
-  if(argint(0, &n) < 0)
+  if (argint(0, &n) < 0)
     return -1;
   addr = myproc()->sz;
-  if(growproc(n) < 0)
+  if (growproc(n) < 0)
     return -1;
   return addr;
 }
 
-int
-sys_sleep(void)
+int sys_sleep(void)
 {
   int n;
   uint ticks0;
 
-  if(argint(0, &n) < 0)
+  if (argint(0, &n) < 0)
     return -1;
   acquire(&tickslock);
   ticks0 = ticks;
-  while(ticks - ticks0 < n){
-    if(myproc()->killed){
+  while (ticks - ticks0 < n)
+  {
+    if (myproc()->killed)
+    {
       release(&tickslock);
       return -1;
     }
@@ -79,8 +105,7 @@ sys_sleep(void)
 
 // return how many clock tick interrupts have occurred
 // since start.
-int
-sys_uptime(void)
+int sys_uptime(void)
 {
   uint xticks;
 
diff --git a/test.c b/test.c
new file mode 100644
index 0000000..ede7287
--- /dev/null
+++ b/test.c
@@ -0,0 +1,173 @@
+
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+#define SIG_DFL 0 //default signal handling
+#define SIG_IGN 1 //ignore signal
+#define SIGKILL 9
+#define SIGSTOP 17
+#define SIGCONT 19
+#include "SaveSigAction.h"
+
+void userHandler1(int signum)
+{
+    printf(1, "NICE! USER HANDLER1 is working signal=%d\n", signum);
+}
+void userHandler2(int signum)
+{
+    printf(1, "NICE! USER HANDLER2 is working signal=%d\n", signum);
+}
+void killHandler(int signum)
+{
+    printf(1, "SIGKILL handler was changed TEST FAILED! signal=%d\n", signum);
+}
+void stopHandler(int signum)
+{
+    printf(1, "SIGSTOP handler was changed TEST FAILED! signal=%d\n", signum);
+}
+
+int main()
+{
+    //______masks two signals and send them_____
+    printf(1,"TEST 1: masks two signals and send them\n");
+    if (fork() == 0){
+        struct sigaction act = {userHandler1, 0};
+        struct sigaction act2 = {userHandler2, 0};
+        sigaction(5, &act, null);
+        sigaction(21, &act2, null);
+        sigprocmask((1 << 5) | (1 << 21));
+        kill(getpid(), 5);
+        kill(getpid(), 21);
+        sigprocmask(0);
+        kill(getpid(), 11);
+        printf(1, "TEST 1 FAILED!!\n");
+        exit();
+    }
+
+
+    wait();
+    printf(1,"\n\n");
+    printf(1,"TEST 2: block signal 4 and SIGKILL\n");
+    //______block signal 4 and SIGKILL__________
+    if (fork() == 0){
+        struct sigaction act = {userHandler1, 1 << SIGKILL};
+        struct sigaction act2 = {userHandler2, 1 << SIGKILL};
+        sigaction(4, &act, null);
+        sigaction(5, &act2, null);
+        sigprocmask((1 << 4) | (1 << SIGKILL));
+        printf(1, "sending kill signal, only one handler should run\n");
+        kill(getpid(), 4);
+        kill(getpid(), 5);
+        kill(getpid(), SIGKILL);
+        sleep(5);
+        printf(1, "TEST 2 FAILED, SIGKILL can't be blocked!\n");
+        exit();
+    }
+
+
+    wait();
+    printf(1,"\n\n");
+    printf(1,"TEST 3: Tries to modify SIGKILL & SIGSTOP + child kill father proccess while SIGSTOP\n");
+    //_______Tries to modify SIGKILL&SIGSTOP + child kill father proccess while SIGSTOP___________
+    if (fork() == 0){
+        struct sigaction act = {killHandler, 0};
+        struct sigaction act2 = {stopHandler, 0};
+        if ((sigaction(SIGSTOP, &act, null)) < 0)
+            printf(1, "Changing SIGSTOP Handler Failed, TEST PASSED!\n");
+        if ((sigaction(SIGKILL, &act2, null)) < 0)
+            printf(1, "Changing SIGKILL Handler Failed, TEST PASSED!\n");
+        int fatherPID = getpid();
+        if (fork() != 0)
+            kill(getpid(), SIGSTOP);
+        if (fatherPID != getpid()){
+            kill(fatherPID, SIGKILL);
+            kill(getpid(),SIGKILL);
+        }
+        printf(1, "TEST 3 FAILED, Both should be killed\n");
+        exit(); //not reached
+    }
+
+    wait();
+    printf(1,"\n\n");
+    printf(1,"TEST 4: USER DEFINED HANDLER test\n");
+    //________USER DEFINED HANDLER test+SIG_DFL/SIG_IGN_________
+    if (fork() == 0){
+        struct sigaction act = {userHandler1, 0};
+        struct sigaction act2 = {userHandler2, 0};
+        struct sigaction act3 = {(void *)SIGCONT, 0};
+        struct sigaction act4 = {(void *)SIG_IGN, 0};
+        sigaction(5, &act, null);
+        sigaction(21, &act2, null);
+        sigaction(8, &act3, null);
+        sigaction(7, &act4, null);
+
+        kill(getpid(), 5);
+        kill(getpid(), 8);
+        kill(getpid(), 21);
+        kill(getpid(), 7); 
+        printf(1, "Good, Exiting TEST 4!\n");
+        kill(getpid(), SIGKILL);    //SIG_DFL=SIGKILL (process should die)
+        printf(1, "TEST 4 FAILED!\n");
+        exit(); //not reached
+    }
+
+    wait();
+    printf(1,"\n\n");
+    printf(1,"TEST 5: SIGSTOP SIGCONT test\n");
+    /*________SIGSTOP SIGCONT test_________*/
+    if (fork() == 0){
+        struct sigaction act = {userHandler1, 0};
+        sigaction(5, &act, null);
+        sigprocmask(0);
+        printf(1, "sending kill(5)\n");
+        kill(getpid(), 5);
+        int fatherPID = getpid();
+        int pid = fork();
+        if (pid != 0)
+            sleep(5);
+        if (pid == 0)
+        {
+            kill(fatherPID, SIGSTOP);
+            sleep(10);
+            kill(fatherPID, SIGCONT);
+            printf(1, "SON finished!\n");
+            exit();
+        }
+
+        printf(1, "SUCCESS! FATHER exiting test...\n");
+        exit();
+    }
+
+    wait();
+    printf(1,"\n\n");
+    printf(1,"TEST 6: SIGKILL while process in SIGSTOP\n");
+    /*____________ SIGKILL while process in SIGSTOP_______*/
+    if (fork() == 0){
+        int fatherPID = getpid();
+        int pid = fork();
+        if (pid != 0)
+            wait();
+        if (pid == 0)
+        {
+            kill(fatherPID, SIGSTOP);
+            kill(fatherPID, SIGKILL);
+            kill(fatherPID, SIGCONT);
+            printf(1, "child exiting...!\n");
+            exit();
+        }
+
+        printf(1, "TEST 6 FAILED, FATHER wasn't killed with SIGKILL after SIGSTOP!\n");
+        exit();
+    }
+
+    wait();     //stress test
+    wait();
+    wait();
+    wait();
+    sleep(1);
+    sleep(1);
+    sleep(1);
+    sleep(100);
+    printf(1,"\ntest.c finished.\n");
+    exit();
+}
diff --git a/trapasm.S b/trapasm.S
index da8aefc..1ba3384 100644
--- a/trapasm.S
+++ b/trapasm.S
@@ -23,6 +23,9 @@ alltraps:
   # Return falls through to trapret...
 .globl trapret
 trapret:
+  pushl %esp
+  call handleSignals
+  addl $4, %esp
   popal
   popl %gs
   popl %fs
@@ -30,3 +33,12 @@ trapret:
   popl %ds
   addl $0x8, %esp  # trapno and errcode
   iret
+
+.globl callSigretASM
+callSigretASM:
+  movl $24, %eax        # sigret is defined as 24
+  int $64               # 64 is T_SYSCALL (interrupt 64 means system call)
+
+.globl endSigretASM
+endSigretASM:
+ 
diff --git a/types.h b/types.h
index e4adf64..93e4523 100644
--- a/types.h
+++ b/types.h
@@ -2,3 +2,4 @@ typedef unsigned int   uint;
 typedef unsigned short ushort;
 typedef unsigned char  uchar;
 typedef uint pde_t;
+#define null (void*)0
diff --git a/user.h b/user.h
index 4f99c52..313a22b 100644
--- a/user.h
+++ b/user.h
@@ -1,39 +1,43 @@
 struct stat;
 struct rtcdate;
+struct sigaction;
 
 // system calls
 int fork(void);
 int exit(void) __attribute__((noreturn));
 int wait(void);
-int pipe(int*);
-int write(int, const void*, int);
-int read(int, void*, int);
+int pipe(int *);
+int write(int, const void *, int);
+int read(int, void *, int);
 int close(int);
-int kill(int);
-int exec(char*, char**);
-int open(const char*, int);
-int mknod(const char*, short, short);
-int unlink(const char*);
-int fstat(int fd, struct stat*);
-int link(const char*, const char*);
-int mkdir(const char*);
-int chdir(const char*);
+int kill(int,int);
+int exec(char *, char **);
+int open(const char *, int);
+int mknod(const char *, short, short);
+int unlink(const char *);
+int fstat(int fd, struct stat *);
+int link(const char *, const char *);
+int mkdir(const char *);
+int chdir(const char *);
 int dup(int);
 int getpid(void);
-char* sbrk(int);
+char *sbrk(int);
 int sleep(int);
 int uptime(void);
+uint sigprocmask(uint sigmask); //Task 2.1.3
+int sigaction(int signum, const struct sigaction * act, struct sigaction *old);
+void sigret(void);
 
 // ulib.c
-int stat(const char*, struct stat*);
-char* strcpy(char*, const char*);
-void *memmove(void*, const void*, int);
-char* strchr(const char*, char c);
-int strcmp(const char*, const char*);
-void printf(int, const char*, ...);
-char* gets(char*, int max);
-uint strlen(const char*);
-void* memset(void*, int, uint);
-void* malloc(uint);
-void free(void*);
-int atoi(const char*);
+int stat(const char *, struct stat *);
+char *strcpy(char *, const char *);
+void *memmove(void *, const void *, int);
+char *strchr(const char *, char c);
+int strcmp(const char *, const char *);
+void printf(int, const char *, ...);
+char *gets(char *, int max);
+uint strlen(const char *);
+void *memset(void *, int, uint);
+void *malloc(uint);
+void free(void *);
+int atoi(const char *);
diff --git a/usertests.c b/usertests.c
index a1e97e7..cb49e7a 100644
--- a/usertests.c
+++ b/usertests.c
@@ -390,9 +390,9 @@ preempt(void)
   }
   close(pfds[0]);
   printf(1, "kill... ");
-  kill(pid1);
-  kill(pid2);
-  kill(pid3);
+  kill(pid1,9);
+  kill(pid2,9);
+  kill(pid3,9);
   printf(1, "wait... ");
   wait();
   wait();
@@ -446,7 +446,7 @@ mem(void)
     m1 = malloc(1024*20);
     if(m1 == 0){
       printf(1, "couldn't allocate mem?!!\n");
-      kill(ppid);
+      kill(ppid,9);
       exit();
     }
     free(m1);
@@ -1503,7 +1503,7 @@ sbrktest(void)
     }
     if(pid == 0){
       printf(stdout, "oops could read %x = %x\n", a, *a);
-      kill(ppid);
+      kill(ppid,9);
       exit();
     }
     wait();
@@ -1532,7 +1532,7 @@ sbrktest(void)
   for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
     if(pids[i] == -1)
       continue;
-    kill(pids[i]);
+    kill(pids[i],9);
     wait();
   }
   if(c == (char*)0xffffffff){
@@ -1576,7 +1576,7 @@ validatetest(void)
     }
     sleep(0);
     sleep(0);
-    kill(pid);
+    kill(pid,9);
     wait();
 
     // try to crash the kernel by passing in a bad string pointer
diff --git a/usys.S b/usys.S
index 8bfd8a1..f84ac87 100644
--- a/usys.S
+++ b/usys.S
@@ -29,3 +29,6 @@ SYSCALL(getpid)
 SYSCALL(sbrk)
 SYSCALL(sleep)
 SYSCALL(uptime)
+SYSCALL(sigprocmask)
+SYSCALL(sigaction)
+SYSCALL(sigret)
diff --git a/x86.h b/x86.h
index 07312a5..0f3ddb7 100644
--- a/x86.h
+++ b/x86.h
@@ -1,60 +1,84 @@
 // Routines to let C code use special x86 instructions.
+static inline int cas(volatile void *addr, int expected, int newval)
+{
+  int ans = 1;
+  asm volatile(
+      "lock; cmpxchg %2,(%3)\n\t"
+      "pushfl\n\t"
+      "popl %%eax\n\t"
+      "and $64, %%eax\n\t"
+      "movl %%eax, %0\n\t"
+
+      : "=m"(ans)                             /* output */
+      : "a"(expected), "c"(newval), "b"(addr) /* input */
+      : "memory"
+
+  );
+  return ans;
+}
+
 
 static inline uchar
 inb(ushort port)
 {
   uchar data;
 
-  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+  asm volatile("in %1,%0"
+               : "=a"(data)
+               : "d"(port));
   return data;
 }
 
 static inline void
 insl(int port, void *addr, int cnt)
 {
-  asm volatile("cld; rep insl" :
-               "=D" (addr), "=c" (cnt) :
-               "d" (port), "0" (addr), "1" (cnt) :
-               "memory", "cc");
+  asm volatile("cld; rep insl"
+               : "=D"(addr), "=c"(cnt)
+               : "d"(port), "0"(addr), "1"(cnt)
+               : "memory", "cc");
 }
 
 static inline void
 outb(ushort port, uchar data)
 {
-  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+  asm volatile("out %0,%1"
+               :
+               : "a"(data), "d"(port));
 }
 
 static inline void
 outw(ushort port, ushort data)
 {
-  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+  asm volatile("out %0,%1"
+               :
+               : "a"(data), "d"(port));
 }
 
 static inline void
 outsl(int port, const void *addr, int cnt)
 {
-  asm volatile("cld; rep outsl" :
-               "=S" (addr), "=c" (cnt) :
-               "d" (port), "0" (addr), "1" (cnt) :
-               "cc");
+  asm volatile("cld; rep outsl"
+               : "=S"(addr), "=c"(cnt)
+               : "d"(port), "0"(addr), "1"(cnt)
+               : "cc");
 }
 
 static inline void
 stosb(void *addr, int data, int cnt)
 {
-  asm volatile("cld; rep stosb" :
-               "=D" (addr), "=c" (cnt) :
-               "0" (addr), "1" (cnt), "a" (data) :
-               "memory", "cc");
+  asm volatile("cld; rep stosb"
+               : "=D"(addr), "=c"(cnt)
+               : "0"(addr), "1"(cnt), "a"(data)
+               : "memory", "cc");
 }
 
 static inline void
 stosl(void *addr, int data, int cnt)
 {
-  asm volatile("cld; rep stosl" :
-               "=D" (addr), "=c" (cnt) :
-               "0" (addr), "1" (cnt), "a" (data) :
-               "memory", "cc");
+  asm volatile("cld; rep stosl"
+               : "=D"(addr), "=c"(cnt)
+               : "0"(addr), "1"(cnt), "a"(data)
+               : "memory", "cc");
 }
 
 struct segdesc;
@@ -64,11 +88,13 @@ lgdt(struct segdesc *p, int size)
 {
   volatile ushort pd[3];
 
-  pd[0] = size-1;
+  pd[0] = size - 1;
   pd[1] = (uint)p;
   pd[2] = (uint)p >> 16;
 
-  asm volatile("lgdt (%0)" : : "r" (pd));
+  asm volatile("lgdt (%0)"
+               :
+               : "r"(pd));
 }
 
 struct gatedesc;
@@ -78,31 +104,38 @@ lidt(struct gatedesc *p, int size)
 {
   volatile ushort pd[3];
 
-  pd[0] = size-1;
+  pd[0] = size - 1;
   pd[1] = (uint)p;
   pd[2] = (uint)p >> 16;
 
-  asm volatile("lidt (%0)" : : "r" (pd));
+  asm volatile("lidt (%0)"
+               :
+               : "r"(pd));
 }
 
 static inline void
 ltr(ushort sel)
 {
-  asm volatile("ltr %0" : : "r" (sel));
+  asm volatile("ltr %0"
+               :
+               : "r"(sel));
 }
 
 static inline uint
 readeflags(void)
 {
   uint eflags;
-  asm volatile("pushfl; popl %0" : "=r" (eflags));
+  asm volatile("pushfl; popl %0"
+               : "=r"(eflags));
   return eflags;
 }
 
 static inline void
 loadgs(ushort v)
 {
-  asm volatile("movw %0, %%gs" : : "r" (v));
+  asm volatile("movw %0, %%gs"
+               :
+               : "r"(v));
 }
 
 static inline void
@@ -123,10 +156,10 @@ xchg(volatile uint *addr, uint newval)
   uint result;
 
   // The + in "+m" denotes a read-modify-write operand.
-  asm volatile("lock; xchgl %0, %1" :
-               "+m" (*addr), "=a" (result) :
-               "1" (newval) :
-               "cc");
+  asm volatile("lock; xchgl %0, %1"
+               : "+m"(*addr), "=a"(result)
+               : "1"(newval)
+               : "cc");
   return result;
 }
 
@@ -134,25 +167,29 @@ static inline uint
 rcr2(void)
 {
   uint val;
-  asm volatile("movl %%cr2,%0" : "=r" (val));
+  asm volatile("movl %%cr2,%0"
+               : "=r"(val));
   return val;
 }
 
 static inline void
 lcr3(uint val)
 {
-  asm volatile("movl %0,%%cr3" : : "r" (val));
+  asm volatile("movl %0,%%cr3"
+               :
+               : "r"(val));
 }
 
 //PAGEBREAK: 36
 // Layout of the trap frame built on the stack by the
 // hardware and by trapasm.S, and passed to trap().
-struct trapframe {
+struct trapframe
+{
   // registers as pushed by pusha
   uint edi;
   uint esi;
   uint ebp;
-  uint oesp;      // useless & ignored
+  uint oesp; // useless & ignored
   uint ebx;
   uint edx;
   uint ecx;
